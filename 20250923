# 📊 NumPy 상세 학습 정리

**작성자**: [Your Name]  
**학습 날짜**: 2025년 9월 24일 (화요일)  
**학습 시간**: 약 3-4시간  
**주요 내용**: NumPy 기본 사용법, 배열 생성, 연산, 통계 함수  
**개발 환경**: Python 3.13, VS Code, Windows

---

## 📑 목차

1. [학습 개요](#-1-학습-개요)
2. [NumPy 기본 개념](#-2-numpy-기본-개념)
3. [배열 생성 방법](#-3-배열-생성-방법)
4. [배열 조작 및 인덱싱](#-4-배열-조작-및-인덱싱)
5. [배열 연산](#-5-배열-연산)
6. [통계 함수](#-6-통계-함수)
7. [트러블슈팅](#-7-트러블슈팅)
8. [실습 코드 모음](#-8-실습-코드-모음)
9. [학습 정리 및 다음 단계](#-9-학습-정리-및-다음-단계)

---

## 🎯 1. 학습 개요

### 1.1 학습 목표

- **기본 목표**
  - NumPy 라이브러리의 핵심 개념 이해
  - 다차원 배열(ndarray) 생성 및 조작 능력 습득
  - 배열 간 연산 및 통계 함수 활용법 학습

- **세부 목표**
  - Python list와 NumPy array의 차이점 이해
  - 1차원, 2차원 배열의 인덱싱 및 슬라이싱 마스터
  - axis 개념을 활용한 통계 연산 수행

### 1.2 사전 지식

- Python 기본 문법 (리스트, 함수, 모듈 import)
- 기본적인 수학 개념 (행렬, 벡터)

---

## 📚 2. NumPy 기본 개념

### 2.1 NumPy란?

**NumPy**(Numerical Python)는 Python에서 과학 계산을 위한 핵심 라이브러리입니다.

#### 주요 특징:
- **N차원 배열 객체**: 효율적인 다차원 배열 지원
- **벡터화 연산**: 반복문 없이 전체 배열에 대한 연산
- **메모리 효율성**: C로 구현되어 빠른 연산 속도
- **브로드캐스팅**: 다른 크기 배열 간 연산 지원

### 2.2 기본 배열 생성 및 속성

```python
# -*- coding: utf-8 -*-
import numpy as np

# 1차원 배열 생성
a = [1, 2, 3, 4, 5]  # Python 리스트
b = np.array(a)      # NumPy 배열로 변환

print("=" * 50)
print("🔍 1차원 배열 분석")
print("=" * 50)
print(f"원본 리스트: {a}")
print(f"NumPy 배열: {b}")
print(f"데이터 타입: {type(b)}")
print(f"배열 타입: {b.dtype}")
print(f"차원 수: {b.ndim}")
print(f"형태: {b.shape}")
print(f"크기: {b.size}")
print(f"메모리 사용량: {b.nbytes} bytes")
```

**출력 결과:**
```
==================================================
🔍 1차원 배열 분석
==================================================
원본 리스트: [1, 2, 3, 4, 5]
NumPy 배열: [1 2 3 4 5]
데이터 타입: <class 'numpy.ndarray'>
배열 타입: int32
차원 수: 1
형태: (5,)
크기: 5
메모리 사용량: 20 bytes
```

### 2.3 2차원 배열 생성

```python
# 2차원 배열 생성
matrix_list = [[1, 2, 3], [4, 5, 6]]
c = np.array(matrix_list)

print("\n" + "=" * 50)
print("🔍 2차원 배열 분석")  
print("=" * 50)
print("2차원 배열:")
print(c)
print(f"차원 수: {c.ndim}")
print(f"형태: {c.shape}")  # (행, 열)
print(f"크기: {c.size}")
print(f"첫 번째 행: {c[0]}")
print(f"두 번째 행: {c[1]}")
print(f"특정 원소 c[0,0]: {c[0, 0]}")
print(f"특정 원소 c[1,2]: {c[1, 2]}")
```

**출력 결과:**
```
==================================================
🔍 2차원 배열 분석
==================================================
2차원 배열:
[[1 2 3]
 [4 5 6]]
차원 수: 2
형태: (2, 3)
크기: 6
첫 번째 행: [1 2 3]
두 번째 행: [4 5 6]
특정 원소 c[0,0]: 1
특정 원소 c[1,2]: 6
```

---

## 🔧 3. 배열 생성 방법

### 3.1 특수 배열 생성 함수

```python
print("\n" + "=" * 50)
print("🔧 특수 배열 생성")
print("=" * 50)

# 1. 영 배열 (zeros)
zeros_2d = np.zeros((2, 2))
zeros_1d = np.zeros(5)
print("2x2 영 배열:")
print(zeros_2d)
print(f"1차원 영 배열: {zeros_1d}")

# 2. 일 배열 (ones)
ones_array = np.ones((2, 2))
print("\n2x2 일 배열:")
print(ones_array)

# 3. 특정 값으로 채우기 (full)
full_array = np.full((2, 3), 5)
print("\n2x3 배열을 5로 채움:")
print(full_array)

# 4. 단위 행렬 (eye)
identity_matrix = np.eye(3)
print("\n3x3 단위 행렬:")
print(identity_matrix)

# 5. 범위 배열 (arange)
range_array = np.arange(0, 10, 2)
print(f"\n0부터 10미만 2씩 증가: {range_array}")

# 6. 등간격 배열 (linspace)
linspace_array = np.linspace(0, 1, 5)
print(f"0부터 1까지 5개 등간격: {linspace_array}")
```

### 3.2 랜덤 배열 생성

```python
print("\n" + "=" * 30)
print("🎲 랜덤 배열 생성")
print("=" * 30)

# 0-1 사이 랜덤 값
random_array = np.random.random((2, 3))
print("2x3 랜덤 배열 (0-1):")
print(random_array)

# 정수 랜덤 값
random_int = np.random.randint(1, 10, (2, 3))
print("\n2x3 정수 랜덤 배열 (1-10):")
print(random_int)

# 정규분포 랜덤 값
normal_array = np.random.normal(0, 1, (2, 3))
print("\n2x3 정규분포 랜덤 배열:")
print(normal_array)
```

---

## 🎪 4. 배열 조작 및 인덱싱

### 4.1 인덱싱 (Indexing)

```python
print("\n" + "=" * 50)
print("🎪 배열 인덱싱 및 슬라이싱")
print("=" * 50)

# 3x3 배열 생성
matrix_3x3 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print("원본 3x3 배열:")
print(matrix_3x3)

# 기본 인덱싱
print(f"\n첫 번째 행: {matrix_3x3[0]}")
print(f"마지막 행: {matrix_3x3[-1]}")
print(f"특정 원소 [1,1]: {matrix_3x3[1, 1]}")
print(f"특정 원소 [2,0]: {matrix_3x3[2, 0]}")
```

### 4.2 슬라이싱 (Slicing)

```python
# 슬라이싱 예시
print("\n📂 슬라이싱 예시:")
print(f"첫 2행, 첫 2열: \n{matrix_3x3[0:2, 0:2]}")
print(f"모든 행, 첫 2열: \n{matrix_3x3[:, 0:2]}")
print(f"첫 2행, 모든 열: \n{matrix_3x3[0:2, :]}")
print(f"마지막 2행, 마지막 2열: \n{matrix_3x3[1:3, 1:3]}")

# 특정 행/열 추출
print(f"\n첫 번째 열: {matrix_3x3[:, 0]}")
print(f"두 번째 행: {matrix_3x3[1, :]}")
```

### 4.3 고급 인덱싱

```python
# 불린 인덱싱
print("\n🔍 고급 인덱싱:")
condition = matrix_3x3 > 5
print(f"5보다 큰 원소들의 불린 마스크:\n{condition}")
print(f"5보다 큰 원소들: {matrix_3x3[condition]}")

# 팬시 인덱싱
rows = [0, 2]
cols = [1, 2]
print(f"특정 위치의 원소들: {matrix_3x3[rows, cols]}")
```

---

## ➕ 5. 배열 연산

### 5.1 기본 산술 연산

```python
print("\n" + "=" * 50)
print("➕ 배열 연산")
print("=" * 50)

# 1차원 배열 연산
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

print(f"배열 a: {a}")
print(f"배열 b: {b}")
print()

# 요소별 연산
print("🧮 기본 산술 연산:")
print(f"덧셈 (a + b): {a + b}")
print(f"뺄셈 (a - b): {a - b}")  
print(f"곱셈 (a * b): {a * b}")
print(f"나눗셈 (a / b): {a / b}")
print(f"거듭제곱 (a ** 2): {a ** 2}")
print(f"나머지 (a % 2): {a % 2}")

# NumPy 함수 사용
print("\n📐 NumPy 함수 사용:")
print(f"np.add(a, b): {np.add(a, b)}")
print(f"np.subtract(a, b): {np.subtract(a, b)}")
print(f"np.multiply(a, b): {np.multiply(a, b)}")
print(f"np.divide(a, b): {np.divide(a, b)}")
```

### 5.2 행렬 연산

```python
print("\n🔢 행렬 연산:")

# 2x2 행렬 생성
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])

print("행렬 A:")
print(arr1)
print("행렬 B:")
print(arr2)

# 행렬 곱셈
matrix_mult = np.dot(arr1, arr2)
print("\n행렬 곱셈 (A · B):")
print(matrix_mult)

# 또는 @ 연산자 사용
matrix_mult2 = arr1 @ arr2
print("\n@ 연산자를 이용한 행렬 곱셈:")
print(matrix_mult2)

# 전치 행렬
print(f"\n행렬 A의 전치:\n{arr1.T}")

# 대각합 (trace)
print(f"행렬 A의 대각합: {np.trace(arr1)}")

# 행렬식 (determinant)
print(f"행렬 A의 행렬식: {np.linalg.det(arr1):.2f}")
```

### 5.3 브로드캐스팅

```python
print("\n📡 브로드캐스팅:")

# 배열과 스칼라 연산
arr = np.array([[1, 2, 3], [4, 5, 6]])
scalar = 10

print("원본 배열:")
print(arr)
print(f"스칼라 값: {scalar}")
print(f"배열 + 스칼라:\n{arr + scalar}")

# 다른 크기 배열 간 연산
arr_1d = np.array([10, 20, 30])
print(f"\n1차원 배열: {arr_1d}")
print(f"2차원 + 1차원 브로드캐스팅:\n{arr + arr_1d}")
```

---

## 📊 6. 통계 함수

### 6.1 기본 통계량

```python
print("\n" + "=" * 50)
print("📊 통계 함수")
print("=" * 50)

# 테스트 배열 생성
data = np.array([[-1, 2, 3], [3, 4, 8]])
print("테스트 배열:")
print(data)
print()

# 기본 통계량
print("📈 기본 통계량:")
print(f"합계: {data.sum()}")
print(f"평균: {data.mean():.4f}")
print(f"중간값: {np.median(data):.4f}")
print(f"표준편차: {data.std():.4f}")
print(f"분산: {data.var():.4f}")
print(f"최솟값: {data.min()}")
print(f"최댓값: {data.max()}")
print(f"범위: {data.max() - data.min()}")
print(f"모든 요소의 곱: {data.prod()}")
```

### 6.2 축별(Axis) 연산

```python
print("\n🎯 축별(Axis) 연산:")
print("배열 형태:", data.shape, "- 2행 3열")
print()

# axis=0: 행 방향 (열별 연산)
print("📊 axis=0 (행 방향, 열별 연산):")
print(f"열별 합계: {data.sum(axis=0)}")
print(f"열별 평균: {data.mean(axis=0)}")
print(f"열별 최댓값: {data.max(axis=0)}")
print(f"열별 최솟값: {data.min(axis=0)}")

# axis=1: 열 방향 (행별 연산)  
print("\n📊 axis=1 (열 방향, 행별 연산):")
print(f"행별 합계: {data.sum(axis=1)}")
print(f"행별 평균: {data.mean(axis=1)}")
print(f"행별 최댓값: {data.max(axis=1)}")
print(f"행별 최솟값: {data.min(axis=1)}")
```

### 6.3 누적 연산

```python
print("\n📈 누적 연산:")
arr = np.array([1, 2, 3, 4, 5])
print(f"원본 배열: {arr}")
print(f"누적합: {np.cumsum(arr)}")
print(f"누적곱: {np.cumprod(arr)}")
print(f"차분: {np.diff(arr)}")
```

### 6.4 상관관계 및 공분산

```python
print("\n🔗 상관관계 및 공분산:")
x = np.array([1, 2, 3, 4, 5])
y = np.array([2, 4, 6, 8, 10])

correlation_matrix = np.corrcoef(x, y)
covariance_matrix = np.cov(x, y)

print(f"x: {x}")
print(f"y: {y}")
print(f"상관계수 행렬:\n{correlation_matrix}")
print(f"공분산 행렬:\n{covariance_matrix}")
```

---

## ⚠️ 7. 트러블슈팅

### 7.1 자주 발생하는 오류들

#### IndexError: 차원 불일치

```python
print("\n" + "=" * 50)
print("⚠️ 트러블슈팅")
print("=" * 50)

print("🚨 IndexError 예제:")
try:
    arr_1d = np.array([1, 2, 3])
    print(f"1차원 배열: {arr_1d}")
    # print(arr_1d[0, 0])  # 이 줄은 오류 발생!
    print("❌ arr_1d[0, 0]는 오류 발생 (1차원 배열에 2차원 인덱스)")
    print(f"✅ 올바른 접근: arr_1d[0] = {arr_1d[0]}")
except IndexError as e:
    print(f"IndexError: {e}")
```

#### SyntaxError: 보이지 않는 문자

```python
print("\n🚨 SyntaxError: 보이지 않는 문자 (U+200B)")
print("증상: 'invalid non-printable character U+200B'")
print("원인: 웹사이트나 문서에서 코드 복사 시 포함되는 특수문자")
print("해결법:")
print("1. 코드를 직접 타이핑")  
print("2. 새 파일에서 작업")
print("3. VS Code에서 보이지 않는 문자 표시 활성화")
print("4. 정규식으로 특수문자 제거: [\\u200B\\u200C\\u200D\\uFEFF]")
```

### 7.2 성능 최적화 팁

```python
print("\n⚡ 성능 최적화 팁:")

# 1. 벡터화된 연산 사용
import time

# 비효율적인 방법: 반복문
def slow_operation(arr):
    result = np.zeros_like(arr)
    for i in range(len(arr)):
        result[i] = arr[i] ** 2
    return result

# 효율적인 방법: 벡터화
def fast_operation(arr):
    return arr ** 2

# 성능 비교
large_array = np.arange(100000)

start = time.time()
slow_result = slow_operation(large_array)
slow_time = time.time() - start

start = time.time()
fast_result = fast_operation(large_array)
fast_time = time.time() - start

print(f"반복문 방식: {slow_time:.4f}초")
print(f"벡터화 방식: {fast_time:.4f}초")
print(f"성능 개선: {slow_time/fast_time:.1f}배 빠름")
```

### 7.3 메모리 관리

```python
print("\n💾 메모리 관리:")
print("1. 적절한 데이터 타입 선택:")
print("   - int8, int16, int32, int64")
print("   - float16, float32, float64")
print("2. 불필요한 복사 피하기:")
print("   - view 사용: arr.view()")
print("   - in-place 연산: arr += 1")
```

---

## 📁 8. 실습 코드 모음

### 8.1 numpy.study.py

```python
# -*- coding: utf-8 -*-
import numpy as np

# 1차원 배열 기본
a = [1, 2, 3, 4, 5]
b = np.array(a)

print("배열:", b)
print("타입:", type(b))
print("차원 수:", b.ndim)
print("형태:", b.shape)
print("첫 번째 원소:", b[0])

# 2차원 배열
c = np.array([[1, 2, 3], [4, 5, 6]])
print("2차원 배열:")
print(c)
print("2차원 배열의 차원 수:", c.ndim)
print("2차원 배열의 형태:", c.shape)
print("2차원 배열 원소 접근 c[0,0]:", c[0, 0])

# 배열 생성 함수들
zeros_2d = np.zeros((2, 2))
zeros_1d = np.zeros(5)
ones_array = np.ones((2, 2))
full_array = np.full((2, 3), 5)

print("영 배열:", zeros_2d)
print("일 배열:", ones_array)
print("특정값 배열:", full_array)
```

### 8.2 배열 슬라이싱 (numpt.study2.py)

```python
# -*- coding: utf-8 -*-
import numpy as np

# 3x3 배열 생성
lst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
arr = np.array(lst)

# 부분 배열 추출 (0:2행, 0:2열)
a = arr[0:2, 0:2]
print("원본 배열:")
print(arr)
print("슬라이싱 결과 [0:2, 0:2]:")
print(a)
```

### 8.3 배열 연산 (numpt.study3.py - 수정 버전)

```python
# -*- coding: utf-8 -*-
import numpy as np

# 1차원 배열 연산
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# 기본 연산
c = a + b
print("덧셈:", c)

# 나눗셈
c = np.divide(a, b)
print("나눗셈:", c)

# 행렬 곱셈
arr1 = [[1, 2], [3, 4]]
arr2 = [[5, 6], [7, 8]]

matrix_a = np.array(arr1)
matrix_b = np.array(arr2)

# 내적 계산
result = np.dot(matrix_a, matrix_b)
print("행렬 곱셈 결과:")
print(result)
```

### 8.4 통계 함수 (numpy.matrix.file.py - 수정 버전)

```python
# -*- coding: utf-8 -*-
import numpy as np

# 2차원 배열 생성
a = np.array([[-1, 2, 3], [3, 4, 8]])

print("배열:")
print(a)

# 기본 통계량
print("전체 합계:", a.sum())
print("평균:", a.mean())
print("표준편차:", a.std())
print("모든 요소의 곱:", a.prod())

# 축별 연산
print("열별 합계 (axis=0):", a.sum(axis=0))
print("행별 합계 (axis=1):", a.sum(axis=1))

# 최솟값, 최댓값
print("최솟값:", a.min())
print("최댓값:", a.max())
print("최솟값 위치:", np.argmin(a))
print("최댓값 위치:", np.argmax(a))
```

---

## 📝 9. 학습 정리 및 다음 단계

### 9.1 오늘 학습한 핵심 개념

- ✅ **NumPy 기본 개념**
  - ndarray 생성 및 기본 속성 확인
  - Python list vs NumPy array 차이점
  - 메모리 효율성 및 성능 이점 이해

- ✅ **배열 생성 방법**
  - `np.array()`, `np.zeros()`, `np.ones()`, `np.full()`
  - `np.eye()`, `np.arange()`, `np.linspace()`
  - 랜덤 배열 생성: `np.random` 모듈

- ✅ **인덱싱 및 슬라이싱**
  - 1차원, 2차원 배열 접근법
  - 기본 슬라이싱 `[start:end]`
  - 다차원 슬라이싱 `[row_slice, col_slice]`
  - 불린 인덱싱 및 팬시 인덱싱

- ✅ **배열 연산**
  - 요소별 연산 (+, -, *, /, **)
  - 행렬 곱셈 (`np.dot()`, `@` 연산자)
  - 브로드캐스팅 개념 및 활용

- ✅ **통계 함수**
  - 기본 통계량: sum, mean, std, var, min, max
  - **axis 개념**: 축별 연산의 핵심
  - 누적 연산: cumsum, cumprod
  - 상관관계 및 공분산

- ✅ **트러블슈팅**
  - IndexError 해결 (차원 불일치)
  - SyntaxError (보이지 않는 문자) 해결
  - 성능 최적화 기법

### 9.2 실습을 통해 얻은 인사이트

1. **axis 개념의 중요성**
   - `axis=0`: 행 방향 연산 (↓, 위에서 아래로)
   - `axis=1`: 열 방향 연산 (→, 왼쪽에서 오른쪽으로)

2. **벡터화의 힘**
   - 반복문 대신 벡터화된 연산 사용 시 대폭적인 성능 향상

3. **메모리 효율성**
   - 적절한 데이터 타입 선택으로 메모리 사용량 최적화

4. **개발 환경의 중요성**
   - 인코딩 설정, 보이지 않는 문자 처리 등

### 9.3 어려웠던 부분

1. **axis 개념 이해**
   - 처음에는 axis=0이 행인지 열인지 헷갈림
   - 해결: "행을 따라 움직이면서 연산" = "열별 결과"

2. **보이지 않는 문자 오류**
   - U+200B 오류가 반복적으로 발생
   - 해결: 모든 코드를 직접 타이핑하는 습관

3. **브로드캐스팅 규칙**
   - 다른 크기 배열 간 연산 시 규칙 이해 필요

### 9.4 다음 학습 계획

#### 📅 단기 목표 (1주일 내)

- [ ] **배열 형태 변환**
  - `reshape()`, `flatten()`, `ravel()`
  - `transpose()`, `swapaxes()`

- [ ] **조건부 연산**
  - `np.where()`, `np.select()`
  - 마스킹
6. [통계 함수](#-6-
# -*- coding: utf-8 -*-
import numpy as np

lst = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

arr = np.array(lst)
a = arr[0:2, 0:2]
print(a)
# -*- coding: utf-8 -*-
import numpy as mp

a - np.array([1,2,3,])
b = np.array([4,5,6])

# 각 요소 더하기
c = a+b
# c = np.add(a,b)
# 각 요소 나누기​

# c = a/b​
c = np.divide(a,b)​
print(c) # [0.25 0.4 0.5]

arr1 = [[1,2],[3,4]]​ #lisrt 변수선언
arr2 = [[5,6],[7,8]]​#list 변수 선언

a = np.array(arr1)​
b = np.array(arr2)​



c= np.dot(a, b)​

print(c)
# -*- coding: utf-8 -*-
import numpy as np​

a = np.array([[-1,2,3],[3,4,8]])​

s = np.sum(a)​

print('sum=',a.sum())

print('sum by row=',a,sum(axis=0)) ##행 방향으로 연산 (위아래 계산)
print('sum by row=',a,sum(axis=1))##가로 방향

print('mean=',a.mean())
print('sd=',a.std())
print('product=',a.prod()) #모든 요소의 곱
# -*- coding: utf-8 -*-
import numpy as np

a = [1, 2, 3, 4, 5]
b = np.array(a)

print("배열:", b)
print("타입:", type(b))
print("차원 수:", b.ndim)      # 배열의 차원 수 (1차원)
print("형태:", b.shape)        # 배열의 형태 (5,) - 5개 원소의 1차원
print("첫 번째 원소:", b[0])   # 배열의 첫 번째 원소 접근

# 2차원 배열 예시
c = np.array([[1, 2, 3], [4, 5, 6]])
print(c)
print("2차원 배열의 차원 수:", c.ndim)
print("2차원 배열의 형태:", c.shape)  # (2, 3) - 2행 3열
print("2차원 배열 원소 접근 c[0,0]:", c[0, 0])  # 첫 번째 행, 첫 번째 열

#배열의 생성
c = np.zeros((2,2))
print(c)
d = np .zeros(5)
print(d)

e = np.ones((2,2))
print(e)

f = np.full((2,3),5)
print(f)
